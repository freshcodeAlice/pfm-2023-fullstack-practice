const bcrypt = require('bcrypt');
const {User} = require('../models');
const {deletePassword} = require('../utils/deletePassword');
const {createToken} = require('../service/tokenService');

/*
Авторизація та аутентифікація юзера


Шифрування - перетворення вхідного тексту на інший з метою забезпечення приватності
HELLO
RPAAE

Хешування - перетворення вхідних даних довільної довжини у рядок фіксованої довжини
Перетворює дані у фарш

HELLO
kjh432kjh1234l1j123

This sunset is amaizing
rkjkj21k34kjh234kjk

Для хешування паролів треба:

1. Прийняти сирий пароль юзера при реєстраці
2. Перетворити його на хеш за допомогою хеш-функції
3. Створюючи нового юзера, створювати його з вже захешованим паролем




*/ 


module.exports.signUp = async (req, res, next) => {
    try {
        const {body} = req;
        const createdUser = await User.create(body); // за потреби можемо вручну перераховувати поля, які передаємо в об'єкті на створення юзера
        const readyUser = deletePassword(createdUser)
        // перед тим, як повертати юзера, треба з об'єкта видалити пароль

        // TODO: створити сесію юзера
        const token = await createToken(readyUser.id, readyUser.email);
        res.status(201).send({data: readyUser, token});
    } catch(error) {
         next(error)
    }
}

module.exports.signIn = async (req, res, next) => {
    try {

     //   1. Прийняти інформацію юзера
        const {body: {email, password}} = req;
     //   2. Знайти юзера в БД за допомогою інфи, яка прийшла разом з запитом (напр, мейл)
     const foundUser = await User.findOne({
        email
     });
     if (!foundUser) {
     //       - якщо такого юзера немає - відповідаємо помилкою (404/400)
        throw new Error('User not found');  // ось тут може бути ваша помилка
     }
     //   3. Якщо такий юзер є - перевіряємо правильність пароля
     // перевірити відповідність пароля можна за допомогою хешованої перевірки
     const result = await bcrypt.compare(password, foundUser.passwordHash);
     console.log(result); // result - true, якщо співпадають, false якщо ні
          //       - якщо пароль не співпав - відповідаємо помилкою (400)
        if(!result) {
            throw new Error('Invalid data');
        }
     //   4. Якщо пароль співпав - створюємо сесію юзера і генеруємо для нього токен для всіх подальших запитів
        const token = await createToken(foundUser.id, foundUser.email);
        res.status(200).send({data: deletePassword(foundUser), token})
      //      Всі наступні (подальші) запити мають приходити з цим виданим токеном
    } catch(error) {
        next(error);
    }
}

/*
Аутентифікація - юзер приходить з логіном та паролем і ми перевіряємо, чи дійсно він зареєстрований, чи підходить пароль

Авторизація - це підтвердження особистості юзера та його прав разом з кожним запитом ПІСЛЯ аутентифікації

Алгоритм аутентифікації:

1. Клієнт надсилає запит на якусь роботу.
Якщо його запит не містить авторизаційної інформації, юзер отримує помилку 401 (Unauthorized). Разом з цією помилкою юзер отримує в заголовці WWW-Authenticate потрібний метод аутентифікації

2. Клієнт надсилає новий запит, який вже містить інформацію для аутентифікації.
Дані перевіряються, і якщо юзер пройшов аутентифікацію, йому видається "довідка", що він аутентифікований.
Довідка = токен авторизація

3. Всі наступні запити на сервер відправляються разом з токеном. 
Токен перевіряється кожен раз, коли юзер приходить з запитом.

Токен має строк придатності (для того, щоби у випадку вкрадення зловмисник через певний час втратив доступ до авторизованого контенту)

Токени створюються сервером, підписуються секретним ключем і передаються клієнту, який надалі використовує цей токен для підтвердження своєї особи.


*/